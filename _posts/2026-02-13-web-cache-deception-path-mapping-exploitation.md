---
title: "Web Cache Deception: Path Mapping Exploitation (PortSwigger Lab)"
date: 2026-02-13 17:00:00 +0300
categories: [Cybersecurity, Web Security]
tags: [Web Cache Deception, PortSwigger, Burp Suite, OWASP]
pin: false
header:
  image: /assets/wcd.png
---

## Introduction

In this lab from PortSwigger Web Security Academy, I explored a vulnerability known as **Web Cache Deception**, specifically caused by inconsistencies in URL path mapping.

At first glance, the application appeared secure as sensitive information was only accessible after authentication. However, by carefully manipulating URL paths and observing cache behavior, I was able to force the caching layer to store private data and retrieve another userâ€™s API key without logging in as them.

This lab completely changed how I think about caching mechanisms in web applications.

---

## Understanding the Scenario

The vulnerability arises when:

- The **origin server** interprets URLs flexibly  
- The **caching layer** interprets file extensions literally  

If these two layers handle paths differently, sensitive responses can accidentally be cached and served to other users.

This mismatch is the core of Web Cache Deception.

---

## Initial Reconnaissance

After logging in with the provided credentials: **wiener : peter**

![Logging into the application using provided credentials](/assets/01-login.png)

*Figure 1: Successful login using wiener:peter.*

I accessed the following endpoint: **/my-account**

![Private account data returned from /my-account](/assets/02-my-account-response.png)

*Figure 2: The /my-account endpoint returning sensitive information.*

The response contained private, user-specific data including an API key.

This confirmed that `/my-account` was a sensitive endpoint and a suitable target.

To test how the application handled path mapping, I modified the request in Burp Repeater: **/my-account/abc**

![Manipulated account still returns account data](/assets/03-path-manipulation.png)

*Figure 3: Additional path segments still mapped to /my-account.*

Surprisingly, the server still returned the same private account information.

This indicated that the backend was abstracting additional path segments and mapping them back to **/my-account**.

That was the first critical observation.

---

## Identifying the Vulnerability

To test whether caching could be triggered, I appended a static file extension: **/my-account/abc.js**

The server responded with: **Cache-Control: max-age=30**

![Response containing Cache-Control header](/assets/04-cache-header.png)

*Figure 4: Cache-Control: max-age=30 detected.*

This immediately raised suspicion.

When I resent the request within the cache duration, the header changed to: **X-Cache: hit**

This confirmed that the response containing sensitive user data had been cached.

At this point, it became clear:

The caching layer was storing private content because it believed the request was for a static resource (`.js` file), while the backend treated it as a dynamic account endpoint.

That mismatch created the vulnerability.

---

## Exploiting the Cache

To exploit the issue, I crafted a URL that would trick the victim (`carlos`) into accessing: **/my-account/abc.js**

![The crafted URL](/assets/05-x-cache-hit.png)

*Figure 5: Crafted URL delivered to the victim.*

When the victim visited this link:

- Their private account response was cached
- The cache stored their API key
- The response could then be retrieved without authentication

![Carlos API key retrieved from cached response](/assets/06-carlos-api-key.png)

*Figure 6: Sensitive API key exposed through cached response.*

This successfully exposed sensitive information belonging to another user.

---

## Why This Is Dangerous

Web Cache Deception can lead to:

- API key exposure  
- Access token leakage  
- Personally identifiable information (PII) disclosure  
- Potential account takeover  

Since cached responses may be served to multiple users, a single triggered request can compromise many accounts within the cache lifetime.

That significantly increases the severity of this vulnerability.

---

## Mitigation Strategies

To prevent Web Cache Deception:

- Disable caching for user-specific endpoints: **Cache-Control: no-store** and **Cache-Control: private**
- Strictly validate URL paths  
- Reject unexpected or abstracted subpaths  
- Configure CDNs and reverse proxies carefully  
- Regularly test cache behavior during security assessments  

Caching should never store authenticated or sensitive responses.

---

## Lessons Learned

This lab completely shifted my perspective on caching mechanisms.

Before this exercise, I primarily viewed caching as a performance optimization feature. I did not fully appreciate how dangerous misconfigured caching layers could be.

What stood out most was how subtle this vulnerability is. The endpoint `/my-account` required authentication, which initially gave the impression of strong access control. However, simply appending a file extension caused the caching layer to treat the response differently.

From this lab, I learned:

- Always test path variations during reconnaissance  
- Inspect cache-related headers carefully  
- Never assume authenticated endpoints are safe from caching flaws  
- Small misconfigurations in web infrastructure can have severe security consequences  

Understanding how multiple layers of an application interact is critical in web security testing.

---
